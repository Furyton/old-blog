<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>about homogeneous coordinates</title>
      <link href="/2021/09/30/about-homogeneous-coordinates/"/>
      <url>/2021/09/30/about-homogeneous-coordinates/</url>
      
        <content type="html"><![CDATA[<hr /><p>这一篇博客是很无聊的东西，随便想的，<strong>毫无意义</strong>，<strong>胡说八道</strong>。</p><p>动机：图形学课中讲到了齐次坐标，提到它对于区分点和向量的重要作用，这里我并不太明白设计它的 motivation 或者出发点。</p><p>这里我胡乱思考一下这个东西</p><h2 id="confusion">confusion</h2><p>齐次坐标是一种能够区分点和向量的一个对仿射空间中的元素的表达方式。实质上对于点和向量两者确有本质上的不同，其他书上也有这方面的讲解（我之前看过一本书的一点点，<em>Vector Calculus, Linear Algebra, and Differerntial Forms A Unified Approach</em>，最开始提到过这一点），<strong>点相加是没有意义的</strong>，两个点相减表示向量是合理的。至于 <span class="math inline">\(P=\alpha_1 P_1+ \alpha_2 P_2+\dots+\alpha_n P_n\)</span> 本质上还是将点先转化成了向量，再做运算，这是线性代数里的思路，就是欧氏空间中的点认为是向量，这里把他看作是点可能是不同学科的定义或想法不同吧。</p><p>有点吹毛求疵、钻牛角尖了。下面开始从另一个角度解释吧。</p><h2 id="仿射空间">仿射空间</h2><p>这里，欧氏空间中的点，我都看作是向量了，名副其实的向量，向量空间里的向量。</p><p>假设我们有一个仿射集合 C，任取里面的一个元素 v，我们会发现 <span class="math inline">\(C - v = \{x-v|x\in C\}\)</span> 是个向量空间。</p><p>齐次坐标形式上是 <span class="math inline">\((x_1,x_2,\dots,x_n,w)\)</span>，<span class="math inline">\(R^{n+1}\)</span> 中的东西，我们尝试赋予 w 一个含义。</p><p>设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(R^{n+1}\)</span> 的一个 n 维的子空间，如 <span class="math inline">\(R^n\)</span>，取单位向量 v 为<span class="math inline">\(A^\perp\)</span>，即 A 的正交补（其实 v 可以随便取），那么 v + A 就是一个仿射集合。我们不妨就称这个仿射集为 C 吧。</p><p>在 <span class="math inline">\(R^{n+1}\)</span> 空间中，从 v 出发，利用施密特过程，构造 n + 1 个规范正交基 (单位向量，两两正交)，它们分别是 <span class="math inline">\(\{v, e_1,\dots,e_n\}\)</span>，其中 <span class="math inline">\(\{e_1,\dots,e_n\}\)</span> 是 A 的基。任意 <span class="math inline">\(R^{n+1}\)</span> 中的点都可以表示为 <span class="math inline">\(x=\alpha_0 v+\alpha_1 e_1 + \dots + \alpha_n e_n\)</span>，把 <span class="math inline">\(\alpha_0\)</span> 放到最后，写成坐标形式(其实一般只有在标准基下才会有坐标)， <span class="math inline">\(\begin{pmatrix} \alpha_1\\ \vdots\\ \alpha_n\\ \alpha_0 \end{pmatrix}\)</span></p><p>w 就是这里的 <span class="math inline">\(\alpha_0\)</span>，但注意，实质上我想让齐次坐标表示 C 这个仿射集合，所以 w 应当取 1 。</p><h2 id="世界线收束">世界线收束</h2><p>取 A 为 <span class="math inline">\(R^n\)</span> （这里n=3了）</p><p>我们定义 C 中的元素为 "点"，A 中的元素为 "向量"。我们最终考虑的空间变成了 <span class="math inline">\(R^n\times \{0,1\}\)</span>，最后一维的 0 和 1 因此就成了 点 和 向量 的一个 indicator。这样很丑，因为一个连续的东西后面跟了一个小的离散的东西。不得已的，我们的表示允许扩展到 <span class="math inline">\(R^{n}\times R\)</span>，但还是要对最后一维做一个 normalization，也就是需要投影到我们这个丑陋的小空间中去。</p><p>舒服一点了。。。</p><p>回到开始的 confusion 部分，为啥 <span class="math inline">\(P=\alpha_1 P_1+ \alpha_2 P_2+\dots+\alpha_n P_n\)</span> 它很对呢，当用上述定义代入坐标去算时，P 的 w 是 1 。</p><p>那什么又叫有意义的表达式呢（如 <span class="math inline">\(P-2\times V+Q\)</span>），算完之后在 <span class="math inline">\(R^n\times \{0,1\}\)</span> 中即可。</p><p>注：这里的例子 <span class="math inline">\(P-2\times V+Q\)</span> 可以分解为 <span class="math inline">\(P-V-V+Q=(P-V)+(Q-V)\)</span>，若不按我们上面的定义去想似乎也能解释的通，两个点的差是向量嘛。但。。。我觉得很不好（又牛角尖了），又是交换律，又是结合律，最初的式子化到最后，过程中明显不是把它当 点 看的。</p><h2 id="性质对应">性质对应</h2><p>这样把坐标中的每一位赋予含义后，一些性质变得更加自然了。</p><h3 id="仿射变换">仿射变换</h3><p><span class="math display">\[\begin{pmatrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}&amp;b_1\\a_{2,1}&amp;a_{2,2}&amp;a_{2,3}&amp;b_1\\a_{3,1}&amp;a_{3,2}&amp;a_{3,3}&amp;b_1\\0&amp;0&amp;0&amp;1\\\end{pmatrix} \times\begin{pmatrix}x_1\\x_2\\x_n\\w\end{pmatrix}\]</span></p><p><span class="math inline">\(w=0\)</span> 意味着我想做 A 这个向量子空间的变换，做的就是线性变换；若 <span class="math inline">\(w=1\)</span>，意味着，我想做 C 这个仿射空间的变换，得到的就是仿射变换。（其实线性变换包含于仿射变换，忽略这一点吧。。。）</p><h2 id="关于-normalization">关于 normalization</h2><p>前面提到了扩展我们的表示到 <span class="math inline">\(R^n\times R\)</span>，然后做一个变换，这里说的很含糊，我其实也不太懂为什么齐次坐标里说好的 0 表示 向量，1 表示 点，然后又整出个 (x,y,w) 先变成 (x/w,y/w,1) 然后说表示的点是 (x/w,y/w)，但还好。</p><p>对于这一步，其实有一个有点点相关的东西叫 perspective function，<span class="math inline">\(P:R^n\times R_{++}\rightarrow R^n\)</span></p><p><span class="math display">\[P(z,t)=z/t\]</span></p><p>保凸的。</p><p>进一步的，有个 Linear-fractional function</p><p><span class="math display">\[f(x)=\frac{Ax+b}{c^Tx+d}\]</span></p><p>其中 <span class="math inline">\(A\in R^{m\times n}\)</span>，<span class="math inline">\(dom\; f=\{x|c^Tx+d&gt;0\}\)</span>，就是 P 跟一个仿射变换 <span class="math inline">\(g(x)=\begin{bmatrix}  A\\c^T \end{bmatrix} x + \begin{bmatrix} b\\d \end{bmatrix}\)</span> 的复合。</p><p>保凸的。。。</p><h2 id="智障的总结">智障的总结</h2><p>这真的是很无聊的东西，可能是我有点强迫症吧，不太喜欢看上去不系统化的、无根无源、的东西。比如现在的深度学习，尽管都看着很玄学，但在当下很多重要的模型中，我们都能在很早之前的文章中找到一些影子，那时还是都在做机器学习、统计学习，这就让人觉得有根可循，有可能能建立起一套理论。说多了。其实跟这个文章没啥关系。。。</p><p>虽然但是，我觉得齐次坐标还是非常方便、有用的，在几何变换上对仿射变换和线性变换做到了形式上的统一。</p><hr /><p>Update：是我浅薄了。。。</p><p>齐次坐标应该不是我之前这么理解的。。。</p><p>就和那个perspective function 一样，可以看作是对 <span class="math inline">\(R^{n+1}\)</span> 空间做了一个 P 映射。记 codomain 为 B=<span class="math inline">\(R^n\)</span>，domain 为 A=<span class="math inline">\(R^{n+1}\)</span>，点 <span class="math inline">\(x\in B\)</span> 的齐次坐标是一个等价类 <span class="math inline">\(\{t\in A|P(t)=x\}\)</span></p><p>用同一个齐次坐标表达的是同一个点，那么欧氏空间 <span class="math inline">\(R^n\)</span> 中的一个无穷远处的点（必须是沿着某条线的方向无穷大的，也就是坐标间需要满足某个恒定的线性关系，到处乱飞的无穷大不可以）可以找到它的一个齐次坐标（w 置为 0），实质上是唯一的。其他点之所以做了什么normalization，是因为他们是等价的，是同一个齐次坐标。</p><p>诚如老师所讲，笛卡尔无穷远处的点称作向量，有限坐标为点。</p><p>还是很有意思的。</p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notes about statistical learning</title>
      <link href="/2021/08/05/notes-about-statistical-learning/"/>
      <url>/2021/08/05/notes-about-statistical-learning/</url>
      
        <content type="html"><![CDATA[<p>最近看了一点关于统计学习的知识，主要是关于knn和线性回归两种模型。两个模型算是入门级的模型了，理应是相当简单易懂的，但书中花了不小的篇幅深入地(for me)探讨了两个模型的异同，着实有趣。但有些琐碎，不得不抓紧记录下来，不然很快就忘记了[]<sub>(￣▽￣)</sub>*</p><p>另外我发现我对概率统计的知识都变得很陌生了，emmm。正在恶补。</p><p>参考书是 The Elements of Statistical Learning</p><h1 id="step-1">step 1</h1><p>首先是对两个模型一个简单的介绍。</p><h2 id="linear-models">Linear Models</h2><p>对于一个 p 维向量的输入，<span class="math inline">\(x^T=\left(x_1,\dots,x_p\right)\)</span>，我们<strong>假设</strong>对应的输出与它是完全的线性关系，或者说是仿射的，即 <span class="math inline">\(\hat{y}=\beta_0+x^T\beta\)</span>，<span class="math inline">\(\beta_0\)</span> 是我们熟知的 bias 。一般会用更紧致的表达 <span class="math inline">\(\hat{y}=x^T\beta\)</span>，也就是将前面的<span class="math inline">\(\beta_0\)</span> 包含进去。</p><p>非常简单的模型，几何意义也非常丰富。</p><p>去拟合它的方法很多，最常用也是最重要的一个方法就是最小二乘法(least squares), 也就是去最小化 RSS (residual sum of squares)。</p><p>幸运的是，这个问题有一个唯一的解析解(如果 <span class="math inline">\(X^TX\)</span> 是非奇异的) <span class="math inline">\(\hat{\beta}=(X^TX)^{-1}X^Ty\)</span> ，这里 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(N \times p\)</span> 的矩阵，注意行、列含义。</p><p>That's it!</p><h2 id="nearest-neighbor-methods">Nearest-Neighbor Methods</h2><p>顾名思义，模型更加简单直接。不需要训练拟合，可以得到非常 "非线性" 的函数。</p><p>和它非常有关的，k=1 时，Voronoi 图。</p><h1 id="step-2">step 2</h1><p>未完 🐟</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Machine Learning </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
            <tag> note </tag>
            
            <tag> Study </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预训练模型学习(PTM)</title>
      <link href="/2021/07/18/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0-PTM/"/>
      <url>/2021/07/18/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0-PTM/</url>
      
        <content type="html"><![CDATA[<h1 id="ptm-in-nlp">PTM in NLP</h1><h2 id="背景">背景</h2><h3 id="语言表示学习">语言表示学习</h3><p>一个核心的任务是对词语进行编码(称为词嵌入)以便后续其他的NLP任务，但容易想到词语的含义依赖于语境，也就是上下文。</p><h4 id="非上下文嵌入">非上下文嵌入</h4><p>早期的词嵌入方法是静态的、上下文无关的。核心的想法类似于查表，通过训练得到一个embedding矩阵，最经典的就是 <a href="https://furyton.github.io/2020/11/11/Word2Vec/">Word2Vec</a> 。模型规模较小、计算效率高，但<strong>上下文无关性以及词汇表有限</strong>都是它很大的问题。如果要用它一般得接上一个上下文的编码器。</p><h4 id="上下文嵌入">上下文嵌入</h4><p>后来为了解决上下文问题，将静态的查表改为了动态的编码，即获得一个编码器，输入一段上下文可以得到对应的编码。各种经典的神经网络模型接踵而至，大致分为三类：基于卷积模型、序列模型和图模型。</p><p>前两种模型对局部信息容易掌握，但<strong>全局信息或者长期信息难以关联起来</strong>。图模型传统上是用结点代表词语，预先定义它的结构来学习，这就很依赖专家知识。后来实践上干脆直接采用全连接的图，让模型自己去学习词之间的关系，具体的是通过注意力机制去计算，而实现这一想法的代表作就是大名鼎鼎的<a href="https://furyton.github.io/2020/11/09/Transformer模型学习笔记/">变形金刚</a>。但由于它模型复杂度很高，偏差就很小，导致<strong>小数据上非常容易过拟合</strong></p><h2 id="为什么要预训练">为什么要预训练</h2><p>主要原因是数据问题，NLP中未标记数据占比太大，为了能利用它们想出的这么一个办法，来学习所谓“通用”的知识，作为下游任务的初始化部分，也可以看作是一种正则化。</p><h2 id="ptm需要考虑的问题">PTM需要考虑的问题</h2><h3 id="训练的任务">训练的任务</h3><p>由于是在未标记的数据上训练，所以很多PTM都是采用无监督或者是自监督。自监督大约就是自己出题自己做。我们也能看到，许多人给自己的模型出了不同的题目，随之产生的模型种类也非常多。</p><ul><li>LM (Language Model)：最常见最普通的无监督任务，就是知道前i个单词，算下一个单词的概率，通过极大似然估计来训练。</li><li>MLM(Masked Language Model)：就是遮住部分单词，去做完形填空，代表作就是BERT。有相当多的衍生和改进版。</li><li>PLM(permutation)：大致就是随机改变某些单词的位置，但假装这就是原始位置(即输入的位置编码还是原始的)，让模型再去做从左往右预测下一个单词的任务。这样模型能够随机的看到上下文的信息，不需要mask。代表作是 XLNet。看上去比较有趣。</li><li>DAE(Denoising autoencoder)：主要就是我给模型输入了一个认为注入了噪声的序列，我希望模型能够将噪声去除。噪声就有很多种了，比如加上Mask(这样就是MLM了)、删掉某个单词、打乱句子顺序等等。</li><li>CTL(Contrastive Learning)：如同我在笔记<a href="https://furyton.github.io/2020/11/11/Word2Vec/">Word2Vec</a> 中提到的，选择一个负样本作为对比来训练，这样降低了计算的复杂度。之前被用在非上下文嵌入上了，最近有新的CTL任务。<ul><li>Deep Infomax ：大致就是把word2vec里的查表部分换成了用编码器。训练任务是Mask，让序列的编码和被遮挡的部分的编码尽可能地相似。</li><li>Replaced Token Detection：上一个任务类似，换了训练目标，预测一个单词是否被替换。</li><li>ELECTRA：生成器加判别器，先用MLM训练生成器，在用它初始化判别器进行训练，判别器的训练任务是判别哪些词被生成器替换了。emmm</li><li>Next Sentence Prediction：BERT提了这个任务，就是判断两个句子是不是连续出现的。但是又来有很多人研究发现去除/不用NSP效果会更好的🤣</li><li>Sentence Order Prediction：把NSP任务里的loss换掉了，作者认为是NSP融合了主题预测和连贯性预测，而前者的子任务更简单所以模型就忽视了后者。SOP是对比学习，把连续的两个句子作为正样本，两个句子顺序交换作为负样本。emmm，很合理。</li></ul></li></ul><h4 id="模型分析">模型分析</h4><ul><li>非上下文嵌入虽然是静态的，但他对于一些预测分类很擅长，类似于"Germany"+"captital" <span class="math inline">\(\approx\)</span> "Berlin" 。</li><li>对于BERT，有很多研究表明它对于句法方面的任务很不错，例如词性识别、成分标记等等，但词义等方面一般般。这被称为“<strong>语言知识</strong>”。除此之外，有部分研究发现BERT对于一些常识性的知识也还不错。“<strong>世界知识</strong>”</li></ul><h3 id="模型压缩">模型压缩</h3><p>PTM太大，有人考虑压缩它。</p><ul><li>剪枝。。。</li><li>量化(不太明白这个命名的意义)，就是降低精度。。。</li><li>模型共享，大概就是参数共享等等。有个比较出名的模型叫ALBERT</li><li>知识蒸馏，大概就是用一个小的student模型去拟合或近似大模型。这方面的研究还挺多。</li><li>模型替换，把PTM中较大的模块换成比较小的模块。</li></ul><h3 id="怎么用到下游任务">怎么用到下游任务</h3><h4 id="选择合适的ptm">选择合适的PTM</h4><p>不同的PTM任务会适合不同的下游任务，PTM模型的结构也多少取决于它的任务，因而也会影响在下游任务的表现。还有数据问题。</p><h4 id="选择合适的层">选择合适的层</h4><p>有人发现BERT较低的层捕捉基本的句法信息，更高的层捕获高层次的语义信息。因而不同的下游任务也可以选择不同的层来使用，比如只用静态嵌入（Word2Vec），难以捕捉高层次信息；还有使用顶层的表示；还有将所有层的表示加权一起使用的。。。</p><h4 id="是否微调">是否微调</h4><ul><li>特征提取：预训练模型参数被冻结。不利预迁移中间层信息。</li><li>微调：PTM的参数不被冻结。很多的下游任务都是采用微调。微调的方式也很多。</li></ul><h2 id="方向">方向</h2><ul><li>PTM上界：更有效的模型结构，任务等。<strong>ELECTRA</strong></li><li>PTM的计算复杂性优化。<strong>Transformer-XL</strong></li><li>模型压缩</li><li>更高效的微调</li><li>可解释性和可靠性。</li></ul><h2 id="小感悟">小感悟</h2><ul><li>模型大了，数据多了，人们说的话也变抽象了。”知识“来、”知识“去，这很抽象。暴力出奇迹，模型太大了，人都快驾驭不了了的😂</li><li>突然发现PTM这块是个不小的领域，有很多的突飞猛进的进展和很多待解决的问题欸。尤其是有这么多的PTM ，感觉入了个大坑。</li></ul><hr /><p>reference：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/139479425">自然语言处理中的预训练模型（上） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/142757748">自然语言处理中的预训练模型（下） - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/sandwichnlp/p/11947627.html">预训练语言模型整理（ELMo/GPT/BERT...） - 西多士NLP - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Machine Learning </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> NLP </tag>
            
            <tag> Pre-Trained Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸集</title>
      <link href="/2021/06/20/%E5%87%B8%E9%9B%86/"/>
      <url>/2021/06/20/%E5%87%B8%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<object data="/files/NOTES/ConvexOptimization/ConvexSet/note.pdf" type="application/pdf" width="100%" height="800px"><b>note</b>:Your browser does not support PDF viewer, please click <a href="/files/NOTES/ConvexOptimization/ConvexSet/note.pdf">here</a> to download the note manually :) --Furyton<hr></object><p>未完待续。。。</p><hr /><p>参考书 Boyd <em>Convex Optimization</em></p><p>Latex 模板来自 <a href="https://github.com/ElegantLaTeX/ElegantNote">ElegentNote from ElegantLaTex</a></p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Basic </category>
          
          <category> Optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Baisc </tag>
            
            <tag> convex set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Topology(I)-Intuition</title>
      <link href="/2021/06/18/BasicTopology(I)-Intuition/"/>
      <url>/2021/06/18/BasicTopology(I)-Intuition/</url>
      
        <content type="html"><![CDATA[<h2 id="build-a-basic-intuition-on-some-classic-topology-spaces">build a basic intuition on some classic topology spaces</h2><h3 id="eulers-theorem">Euler's theorem</h3><p>for a polyhedron P ,we have v - e + f = 2</p><p>two conditions on P need to be satisfied:</p><ul><li>any two vertices can be connected by edges on P</li><li>any loop made up of straight lines divides P into two pieces</li></ul><p>对此有两个非常有启发性的证明.</p>]]></content>
      
      
      <categories>
          
          <category> extend </category>
          
          <category> Topology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
            <tag> Topology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于微程序设计的CPU实验</title>
      <link href="/2021/04/10/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84CPU%E5%AE%9E%E9%AA%8C/"/>
      <url>/2021/04/10/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84CPU%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="微指令格式">微指令格式</h1><p>32 bit</p><p><strong>31</strong>: HALT 30..26 : S <strong>25</strong> : CN <strong>23</strong> : CP_PC <strong>22</strong> : CP_MAR <strong>21</strong> : CP_R <strong>20</strong> : CP_IR <strong>19</strong> : R_enable <strong>18</strong> : R_wen <strong>17..15</strong> : MUX_A <strong>14..12</strong> : MUX_B</p><p><strong>11..10</strong> : MUX_R_INA <strong>9..8</strong> : MUX_R_INB <strong>7..6</strong> : MUX_R_OUT <strong>5</strong> : RD <strong>4</strong> : WE <strong>3</strong> : MUX_ADDR <strong>2..0</strong> : code</p><p><strong>31..24</strong> : Addr</p><p>## explanation</p><p>S, CN 为 ALU的操作码</p><p>R_enable : reg_file 使能信号</p><p>R_wen ：reg_file 写信号</p><p>MUX_A, MUX_B ：A，B选择器</p><p>MUX_R_INA ：A选择器中，reg_file 选择IR中哪一个位置的寄存器号</p><p>MUX_R_INB ：B选择器中，reg_file 选择IR中哪一个位置的寄存器号</p><p>MUX_R_OUT ：ALU的输出，reg_file 选择IR中哪一个位置的寄存器号</p><p>RD ：RAM读使能</p><p>WE：RAM写使能</p><p>MUX_ADDR：选择PC、MAR作为RAM地址线</p><p>code：下地址寻址方式</p><h1 id="isa">ISA</h1><p>参考MIPS 16bit指令集格式</p><p>指令均为单字长(16 bit)，通用寄存器有8个，均为16 bit</p><p>操作码为5位</p><p>按指令格式区分，有六类指令</p><ul><li><table><thead><tr class="header"><th style="text-align: center;">OPT</th><th style="text-align: center;">R1(source)</th><th style="text-align: center;">R2(source)</th><th style="text-align: center;">R3(destination)</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">2 bits</td></tr></tbody></table><ul><li><strong>ADD</strong>， R1+R2 =&gt; R3</li><li><strong>SUB</strong>， R1-R2 =&gt; R3</li><li><strong>MULT</strong>, R1 * R2 =&gt; R3</li><li><strong>DIV</strong>, R1 / R2 =&gt; R3</li><li><strong>AND</strong>, R1 &amp; R2 =&gt; R3</li><li><strong>OR</strong>, R1 | R2 =&gt; R3</li><li><strong>XOR</strong>, R1 ^ R2 =&gt; R3</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;">OPT</th><th style="text-align: center;">R1(source)</th><th style="text-align: center;"></th><th style="text-align: center;">R3(destination)</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">2 bits</td></tr></tbody></table><ul><li><strong>NOT</strong>, ~R1 =&gt; R3</li><li><strong>SHL</strong>, R1&lt;&lt;1 =&gt; R3</li><li><strong>SHR</strong> R1&gt;&gt;1 =&gt; R3</li><li><strong>MOV</strong>, R1 =&gt; R3</li><li><strong>LD</strong>, M[R1] =&gt; R3</li><li><strong>ST</strong>, R1 =&gt; M[R3]</li></ul></li><li><table><thead><tr class="header"><th style="text-align: left;">OPT</th><th style="text-align: left;">R1(destination)</th><th style="text-align: left;">Immediate number(source)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">5 bits</td><td style="text-align: left;">3 bits</td><td style="text-align: left;">8 bits</td></tr></tbody></table><ul><li><strong>MVH</strong> immediate =&gt; High_Byte(R1)</li><li><strong>MVL</strong> immediate =&gt; Low_Byte(R1)</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;">OPT</th><th style="text-align: center;">R1(source)</th><th style="text-align: center;">R2(destination)</th><th style="text-align: center;">Immediate number</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">5 bits</td></tr></tbody></table><ul><li><strong>ADDI</strong> R1 + immediate =&gt; R2</li><li><strong>SUBI</strong> R1 - immediate =&gt; R2</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;">OPT</th><th style="text-align: center;">R1</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5 bits</td><td style="text-align: center;">3 bits</td><td style="text-align: center;">8bits</td></tr></tbody></table><ul><li><strong>UJMP</strong> PC jumps unconditionally to R1</li><li><strong>CJMP</strong> PC jumps to R1 when C0 = 1</li><li><strong>ZJMP</strong> PC jumps to R1 when FZ = 1</li><li><strong>MOVSP</strong> R1 =&gt; SP</li><li><strong>PUSH</strong> push R1 =&gt; stack[SP], SP ++</li><li><strong>POP</strong> stack[SP] =&gt; R1, SP--</li><li><strong>CALL</strong> run subroutine at R1</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;">OPT</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5 bits</td><td style="text-align: center;">11 bits</td></tr></tbody></table><ul><li><strong>RET</strong> return from subroutine</li><li><strong>RST</strong> 0 =&gt; PC</li><li><strong>HALT</strong> 1 =&gt; halt</li></ul></li></ul><h2 id="与讲义中的设计不同的地方">与讲义中的设计不同的地方</h2><ul><li>通用寄存器数量、指令字长等均有所增加。</li><li>ALU拥有更多其他的功能，如无符号整数乘法、高（低）位byte的操作、存储A、B输入是否相等、结果是否溢出等等。</li><li>指令的功能更加丰富，包括基本的逻辑和算术运算、有（无）条件跳转、栈的操作、简单的子程序调用等。</li><li>A、B选择器并没有设计为互斥，故ALU的A、B输入端可以同时传入。</li><li>PC、MAR、通用寄存器等的时钟脉冲没有设计为互斥，可以在同一上升沿中一起进行寄存。</li><li>下地址字段的设计进行了改动，如：100表示下一个微地址为取指指令所在的微程序，简化了指令的微程序编写。</li><li>指令均为单字长指令，且大部分为寄存器寻址，每条指令的微程序大大简化。</li><li>缺点：由于指令集的精简，一些原本基本的操作可能需要1-3个指令才能实现。</li></ul><h2 id="cpu电路设计图">CPU电路设计图</h2><h3 id="cpu核心">CPU核心</h3><figure><img src="\upload_image\core.png" class="lazy" data-srcset="\upload_image\core.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="CPU core" /><figcaption aria-hidden="true">CPU core</figcaption></figure><h3 id="控制电路微程序控制">控制电路（微程序控制）</h3><figure><img src="\upload_image\CU.png" class="lazy" data-srcset="\upload_image\CU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="CU" /><figcaption aria-hidden="true">CU</figcaption></figure><h3 id="cpu整体">CPU整体</h3><figure><img src="\upload_image\microcodeCPU.png" class="lazy" data-srcset="\upload_image\microcodeCPU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="CPU" /><figcaption aria-hidden="true">CPU</figcaption></figure><h2 id="数据通路">数据通路</h2><h3 id="通用寄存器选择方式">通用寄存器选择方式</h3><h4 id="alu-的输入">ALU 的输入</h4><p>由于指令中有三个固定的位置上会出现寄存器的编号，因此设置了两层选择器，第一个是用来选择是启用指令中的R1、R2还是R3，第二个是A，B选择器，两个选择器都能够选择输入寄存器中的数据，即reg_files 为双端口输出。</p><h4 id="alu的输出">ALU的输出</h4><p>输出只需选择启用指令中的R1、R2还是R3。</p><h4 id="说明">说明</h4><p>指令上的选择器保留了00，即寄存器000号。它被作为SP（Stack Pointer）</p><h3 id="数据通路-1">数据通路</h3><ul><li>reg_file: 通用寄存器组，8*16 bit，双端口输出</li><li>ALU ： 有S0...S4，CN六个控制端，用以选择运算类型</li><li>寄存器C0，FZ：分别用来保存ALU产生的进位信号和A、B相等信号</li><li>RAM：读写操作分别收WE和RE信号控制</li><li>MAR：RAM的地址寄存器</li><li>IR：指令寄存器</li></ul><p>数据通路采用CPU内部三总线方式</p><ul><li>寄存器之间的数据传输<ul><li><span class="math inline">\(R1 \overset{A 选择器}{\rightarrow} ALU \overset{A 直传}{\rightarrow} R2\)</span></li></ul></li><li>RAM 和 CPU之间的数据传输<ul><li><span class="math inline">\(PC/MAR \overset{Bus, RE=1}{\rightarrow} RAM \overset{A 选择器} ALU \overset{A 直传}{\rightarrow} IR\)</span></li><li><span class="math inline">\(PC/MAR \overset{Address Bus, WE=1}{\rightarrow} RAM, ALU \overset{Data Bus}{\rightarrow} RAM\)</span></li></ul></li><li>算术运算<ul><li><p><span class="math inline">\(R1(IR) \overset{A 选择器}{\rightarrow} ALU, R2(IR) \overset{B 选择器}{\rightarrow} ALU, ALU \overset{S, CN}{\rightarrow} R3(IR)\)</span></p></li><li><p>$PC ALU PC $</p></li></ul></li></ul><h2 id="指令流程">指令流程</h2><figure><img src="\upload_image\指令执行流程.png" class="lazy" data-srcset="\upload_image\指令执行流程.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="Instruction flow" /><figcaption aria-hidden="true">Instruction flow</figcaption></figure><h2 id="测试指令">测试指令</h2><p>暂无</p><h2 id="代码">代码</h2><p><a href="/files/HW/Computer%20Organization%20experiment/exp3/exp03.zip" title="code.zip contains the vhd codes and some .bdf files">click to download</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Organization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU design </tag>
            
            <tag> experiment </tag>
            
            <tag> homework </tag>
            
            <tag> microcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Analysis introductory Series - Basic inequalities</title>
      <link href="/2021/03/17/Linear-Analysis-introductory-Series-Basic-inequalities/"/>
      <url>/2021/03/17/Linear-Analysis-introductory-Series-Basic-inequalities/</url>
      
        <content type="html"><![CDATA[<h2 id="凸函数">凸函数</h2><h3 id="jensen-theorem">Jensen Theorem</h3><p>convex function f <span class="math display">\[f\left( \sum_{i=1}^{n}p_ix_i\right) \le \sum_{i=1}^{n}f(p_ix_i)\]</span> <span class="math inline">\(x_i \in \mathbf{dom}f\)</span> , <span class="math inline">\(\mathbf{p} \in\)</span> 概率单纯形</p><ul><li>AM-GM</li><li><span class="math inline">\(\sum t_i log x_i \le log \sum t_ix_i\)</span></li></ul><h2 id="others">others</h2><h3 id="varphi-mean"><span class="math inline">\(\varphi-mean\)</span></h3><p><span class="math inline">\(\varphi : (0,+\infty) \rightarrow \mathbf{R}\)</span> continuous and <strong>strictly monotonic</strong></p><p><span class="math inline">\(\varphi-mean\)</span> of a sequence <span class="math inline">\(a\)</span> (<span class="math inline">\(a_i\gt0\)</span>): <span class="math display">\[M_\varphi(a)=\varphi^{-1}\left(\sum_{i=1}^{n}p_i\varphi(a_i)\right)\]</span></p><h4 id="when-m_psi-and-m_varphi-comparable">when <span class="math inline">\(M_\psi\)</span> and <span class="math inline">\(M_\varphi\)</span> comparable?</h4><p><span class="math inline">\(\varphi, \psi:(0,+\infty)\rightarrow \mathbf{R}\)</span> continuous and strictly monotonic s.t. <span class="math inline">\(\varphi\psi^{-1}\)</span> is <span class="math inline">\(\left\{\begin{matrix} concave ,&amp; \varphi\;is\;increasing\\ convex ,&amp; \varphi\;is\;decreasing \end{matrix}\right.\)</span> <span class="math display">\[M_\varphi(a)\le M_\psi(a)\]</span> <strong>proof</strong> <span class="math display">\[M_\varphi(a)=\varphi^{-1}\left(\sum_{i=1}^{n}p_i\varphi(a_i)\right)\\\\ = \varphi^{-1}\left(\sum_{i=1}^{n}p_i\varphi\psi^{-1}(b_i)\right)\\\\\le \varphi^{-1}\left(\varphi\psi^{-1}\left(\sum_{i=1}^{n}p_ib_i\right)\right) =M_\psi(a)\]</span> for <span class="math inline">\(\varphi\)</span> is increasing</p><h3 id="special-case">special case</h3><p>when <span class="math inline">\(\varphi(t)=t^r\;(-\infty\lt r \lt +\infty,\; r\ne 0)\)</span> , write <span class="math inline">\(M_r\)</span> for <span class="math inline">\(M_\varphi\)</span></p><p><span class="math inline">\(M_\infty\)</span> = <span class="math inline">\(\max_{1\le i\le n} a_i\)</span>, <span class="math inline">\(M_{-\infty}\)</span> = <span class="math inline">\(\min_{1\le i\le n} a_i\)</span>, <span class="math inline">\(M_0\)</span> = <span class="math inline">\(\prod{a_i^{p_i}}\)</span>,</p><h5 id="property">property</h5><p><span class="math inline">\(M_r\)</span> is continuous monotone increasing function</p>]]></content>
      
      
      <categories>
          
          <category> extend </category>
          
          <category> Linear Analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> Study </tag>
            
            <tag> Linear Analysis </tag>
            
            <tag> inequalities </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combinatorics course note - Turan problem</title>
      <link href="/2021/03/06/Combinatorics-course-note-Turan-problem/"/>
      <url>/2021/03/06/Combinatorics-course-note-Turan-problem/</url>
      
        <content type="html"><![CDATA[<p>update: fix exercise ex2</p><hr /><p>课程链接 <a href="http://homepages.warwick.ac.uk/staff/H.Liu.9/topic-comb-sdu2021.html" title="Topic in Combinatorics">Course Link</a></p><p>闲来无事听的课，看看自己能坚持多久</p><p>习题解答并不能保证正确性</p><h2 id="turan-problem">Turan Problem</h2><p>就是求解一个数 extremal number of a graph H <span class="math display">\[ex(n,H)=max\{e(G) : |G|=n \, and \, G \;is \; H-free\}\]</span> 在顶点数量限制下，不包含子图H，最大化边的数量</p><p>第一个结果是triangle-free的extremal number (Mantel 1907) <span class="math display">\[e(G)\le ex(n,K_3)= \left \lfloor n^2/4 \right \rfloor\]</span> 最大的图是两边各有 <span class="math inline">\(\left \lfloor n/2 \right \rfloor\)</span> 个点的二分图</p><h3 id="exercise">exercise</h3><ul><li>ex1: 选择n个无理数，怎么才能<span class="math inline">\(max\{\#(x_i,x_j):x_i+x_j \in Q\}\)</span><ul><li>A：转化成图的问题，两个数和如果是有理数那么就有一条边，否则没有。注意到图中不能有三角形，那么根据上面的定理就解决了。</li></ul></li><li>ex2: 证明对于任意一个k个顶点的树 T, <span class="math inline">\(ex(n,T)\le kn\)</span><ul><li>A: 如果图G有<span class="math inline">\(kn\)</span>个边，那么一定能够找到它的一个子图G'，其最小度数大于等于k。简证：从G出发一步步删点，注意到开始时平均度数等于2k。若在某一步中得到图<span class="math inline">\(G^\prime\)</span>，图中有一个点v度数小于k，那么把他去掉，得到的平均度数为 <span class="math display">\[ \frac{\sum_{u\in G^\prime} d_{G^\prime}(u)-2d_{G^\prime}(v)}{|G^\prime|-1}\gt \frac{\sum_{u\in G^\prime} d_{G^\prime}(u)}{|G^\prime|} = \frac{2e(G^\prime)}{|G^\prime|}\ge 2k\]</span> 这个平均值在一直增加，故最终一定可以得到所需的子图</li><li>T 可以表示成一个序列<span class="math inline">\([v_1,v_2,\dots,v_k]\)</span> ，对每个<span class="math inline">\(v_i\)</span> ，只有唯一个点<span class="math inline">\(v_j \in [v_1,\dots,v_{i-1}]\)</span> ，<span class="math inline">\(v_i\)</span>和<span class="math inline">\(v_j\)</span>相连。由此可以构造性的证明，上述得到的子图G'包含所有k顶点的树。</li></ul><h3 id="extremal-structure">extremal structure</h3></li></ul><h4 id="turan">turan</h4><p>r-partite turan graph =&gt; <span class="math inline">\(T_r(n)\)</span> <span class="math display">\[ex(n,K_{r+1})=e(T_r(n))=(1-\frac{1}{r})\frac{n^2}{2}-O(r), \quad r\in N,r\ge2\]</span></p><h4 id="stability">stability</h4><p>let <span class="math inline">\(\epsilon &gt; 0\)</span>, exists <span class="math inline">\(\delta &gt; 0\)</span>, G be an n-vertex <span class="math inline">\(K_{k+1}\)</span> -free graph, if <span class="math display">\[e(G)\ge ex(n,K_{r+1})-\delta n^2\]</span> then G can be changed to <span class="math inline">\(T_r(n)\)</span> by altering at most <span class="math inline">\(\epsilon n^2\)</span> adjacencies</p><h3 id="motzkin-straus">Motzkin-Straus</h3><p><span class="math display">\[f_G(x)=x^TA_Gx=\sum_{v_iv_j\in e(G)}x_ix_j\]</span></p><p><span class="math inline">\(\boldsymbol{x}\)</span> in <span class="math inline">\(S_n\)</span>， 其中 <span class="math inline">\(S_n\)</span> 是概率单纯形。</p><p><span class="math inline">\(\boldsymbol{x}\)</span> 是n维的，所以可以看作是<span class="math inline">\(V(G)\)</span>上的一个权重。</p><p>有<span class="math inline">\(f_G(\boldsymbol{x})=2e(G_x)\)</span> , <span class="math inline">\(e(G_x)\)</span> 是加权边的和，权重是两个顶点权重的乘积</p><p>定理内容：</p><p>图G，<span class="math inline">\(cl(G)=k\)</span>，那么对于任意一个 <span class="math inline">\(\boldsymbol{x}\)</span> in <span class="math inline">\(S_n\)</span> 都有一个<span class="math inline">\(\boldsymbol{y}\in S_n\)</span>， <span class="math display">\[\left\{\begin{matrix}f_G(y)\ge f_G(x)\\supp(y)=K_k\end{matrix}\right.\]</span> 进一步可知，<span class="math inline">\(f_G(\boldsymbol{x})\le \frac{k-1}{k}\)</span></p><p>实质上是给了一个最优化问题的解</p><p>证明略</p><h4 id="exercise-1">exercise</h4><ul><li>ex3: 证明 n个顶点的图<span class="math inline">\(G\)</span>，两个子图<span class="math inline">\(G_1,G_2\)</span> ，任取<span class="math inline">\(\boldsymbol{x}\)</span> in <span class="math inline">\(S_n\)</span>， 存在<span class="math inline">\(\boldsymbol{y}\in S_n\)</span>，满足1. <span class="math inline">\(f_{G_i}(\boldsymbol{y})\ge f_{G_i}(\boldsymbol{x})\)</span> ，2. <span class="math inline">\(\alpha(G[supp(\boldsymbol{y})])\le 2\)</span> , (max independent number)<ul><li>A: 只有个大概思路，没有具体去做。假设有三个点independent，鸽巢原理，至少有两个点属于一个子图，不妨设为<span class="math inline">\(G_1\)</span>，做类似上述定理的证明，证明中所构造的<span class="math inline">\(\boldsymbol{y&#39;}\)</span> 恰好同样满足在<span class="math inline">\(G_2\)</span>中的不等式。</li></ul></li><li>ex4: 证明一个有关一类图的邻接矩阵特征值的界。图G，<span class="math inline">\(cl(G)=k\)</span> ，<span class="math inline">\(A_G\)</span>邻接矩阵，有 <span class="math inline">\(\lambda_1(A_G)^2\le \frac{k-1}{k}\left \| A \right \|_F^2\)</span>，<span class="math inline">\(\lambda_1\ge \lambda_2\ge \dots\)</span><ul><li>A: 设 <span class="math inline">\(\lambda_1\)</span> 的特征向量为 <span class="math inline">\(\boldsymbol{y}\; ,\left \| \boldsymbol{y} \right \|=1\)</span> ，注意：<span class="math inline">\(\sum_{i=1}^n y_i^2=1\)</span>，<span class="math inline">\(\left \| A \right \|_F^2=2e(G)\)</span>,</li><li><span class="math inline">\(\lambda_1^2=f_{G_A}^2(\boldsymbol{y})=(\sum y_iy_j)^2\le 2e\sum y_i^2y_j^2\le \frac{k-1}{k}\left \| A \right \|_F^2\)</span></li></ul></li></ul><h2 id="erdos-simonovits-stone">Erdos-Simonovits-Stone</h2><p><span class="math inline">\(\forall H\)</span> <span class="math display">\[ex(n,H)=\left ( 1-\frac{1}{\chi(H)-1}+o(1) \right )\frac{n^2}{2}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> extend </category>
          
          <category> Graph Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> Study </tag>
            
            <tag> Graph Theory </tag>
            
            <tag> Turan problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VHDL语言入门笔记</title>
      <link href="/2021/03/04/VHDL%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/04/VHDL%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="at-the-beginning">at the beginning</h1><p>the differences between VHDL and software programming languages</p><h2 id="serial-vs.-parallel">Serial vs. Parallel</h2><p><strong>concurrency</strong>:</p><p>​ VHDL: all the codes are execute at the <strong>same</strong> time. =&gt; parallel language</p><h1 id="notes">notes</h1><h3 id="basic">basic</h3><h4 id="library">library</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">library</span> ieee;<br><span class="hljs-keyword">use</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br>....<br></code></pre></td></tr></table></figure><h4 id="entity">entity</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">entity</span> name_same_with_filename <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span> ( <span class="hljs-comment">-- the ports opened for the users</span><br>input_1: <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>; <span class="hljs-comment">-- std_logic have more than states &#x27;1&#x27; and &#x27;0&#x27;</span><br>        ...<br>        result: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span> <span class="hljs-comment">-- PortName : &lt;mode&gt; &lt;type&gt;</span><br>        <span class="hljs-comment">-- the last port is not followed by a &#x27;;&#x27;</span><br>);<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">entity</span>; <span class="hljs-comment">-- remember the &#x27;;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="architecture">architecture</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">architecture</span> arch_name <span class="hljs-keyword">of</span> entity_name <span class="hljs-keyword">is</span><br>    <span class="hljs-comment">-- signal declarations(used for internal connections)</span><br>   <span class="hljs-keyword">signal</span> name: <span class="hljs-built_in">bit</span>;<br>    <span class="hljs-comment">-- constant</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">-- behavioral of the system</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">architecture</span>;<br></code></pre></td></tr></table></figure><h4 id="a-simple-and_gate-example">a simple and_gate example</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">library</span> ieee;<br><span class="hljs-keyword">use</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br> <br><span class="hljs-keyword">entity</span> example_and <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">port</span> (<br>    input_1    : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>    input_2    : <span class="hljs-keyword">in</span>  <span class="hljs-built_in">std_logic</span>;<br>    and_result : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span><br>    );<br><span class="hljs-keyword">end</span> example_and;<br> <br><span class="hljs-keyword">architecture</span> rtl <span class="hljs-keyword">of</span> example_and <span class="hljs-keyword">is</span><br>  <span class="hljs-keyword">signal</span> and_gate : <span class="hljs-built_in">std_logic</span>;<br><span class="hljs-keyword">begin</span><br>  and_gate   &lt;= input_1 <span class="hljs-keyword">and</span> input_2;<br>  and_result &lt;= and_gate;<br><span class="hljs-keyword">end</span> rtl;<br></code></pre></td></tr></table></figure><p>saved as example_and.vhd</p><p>to generate a symbol of example_and , then insert it in the diagram file</p><ul><li>File -&gt; create/update -&gt; create symbol files ...</li></ul><h3 id="process">process</h3><p>often used for sequential logic (require a clock to operate)</p><p>not common usage for combinational logic (do not require a clock)</p><h4 id="example-of-flip-flop">example of flip-flop</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">library</span> ieee;<br><span class="hljs-keyword">use</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br><br><br><span class="hljs-keyword">entity</span> test <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span> (<br>i_clock : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>q1, q2, q3, q4 : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span><br>);<br><span class="hljs-keyword">end</span> test;<br><br><br><span class="hljs-keyword">architecture</span> rtl <span class="hljs-keyword">of</span> test <span class="hljs-keyword">is</span><br><br><span class="hljs-keyword">signal</span> test1 : <span class="hljs-built_in">std_logic</span> := <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-keyword">signal</span> test2 : <span class="hljs-built_in">std_logic</span> := <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">signal</span> test3 : <span class="hljs-built_in">std_logic</span> := <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">signal</span> test4 : <span class="hljs-built_in">std_logic</span> := <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">begin</span><br><br>flip : <span class="hljs-keyword">process</span> (i_clock) <span class="hljs-keyword">is</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> rising_edge(i_clock) <span class="hljs-keyword">then</span><br>test2 &lt;= test1;<br>test3 &lt;= test2;<br>test4 &lt;= test3;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span> flip;<br>    <br>    <span class="hljs-comment">-- or without a name</span><br>            <br>    <span class="hljs-comment">-- process (i_clock)</span><br><span class="hljs-comment">-- begin</span><br><span class="hljs-comment">-- if rising_edge(i_clock) then</span><br><span class="hljs-comment">-- test2 &lt;= test1;</span><br><span class="hljs-comment">-- test3 &lt;= test2;</span><br><span class="hljs-comment">-- test4 &lt;= test3;</span><br><span class="hljs-comment">-- end if;</span><br><span class="hljs-comment">-- end process;</span><br><br>q1 &lt;= test1;<br>q2 &lt;= test2;<br>q3 &lt;= test3;<br>q4 &lt;= test4;<br><br><span class="hljs-keyword">end</span> rtl;<br></code></pre></td></tr></table></figure><p>saved as test.vhd</p><h3 id="component">component</h3><p>component 可以将某个完成的组件作为当前系统的一个子系统。需要在architecture内，begin前声明，在begin内具体化一个实例，同时定义好component的port所对应的signal，也就是port map。另外，各种design file都可以引用来作为一个component，Quartus提供了Create VHDL Component Declaration File功能，生成一个.cmp文件，内容是自动生成的对应component声明语句，非常方便。</p><h4 id="example-of-component">example of component</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">library</span> ieee;<br><span class="hljs-keyword">use</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br><br><span class="hljs-keyword">entity</span> uPC <span class="hljs-keyword">is</span><br><span class="hljs-keyword">port</span>(<br>LOAD : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>CPuPC  : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>E   : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>CLR  : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<br>D    : <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">15</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br>Q    : <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">15</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>)<br>);<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">entity</span> uPC;<br><br><br><span class="hljs-keyword">architecture</span> rtl <span class="hljs-keyword">of</span> uPC <span class="hljs-keyword">is</span><br><br><span class="hljs-keyword">COMPONENT</span> f74161 <span class="hljs-comment">-- f74161是Quartus library所带的74161的bdf文件，实质上在图形界面里使用的是它的一个子部件调用，还有一个p74161，貌似是根据device family来选择两者，具体的细节不太了解。</span><br><span class="hljs-keyword">PORT</span> <span class="hljs-comment">-- 声明port</span><br>(<br>CLRN: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>LDN: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>D: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>C: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>B: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>ENP: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>A: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>ENT: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>CLK: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>RCO: <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>QD: <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>QC: <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>QB: <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>QA: <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span><br>);<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">COMPONENT</span>;<br><br><span class="hljs-keyword">signal</span> rco_wire : <span class="hljs-built_in">std_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<br><span class="hljs-keyword">signal</span> useless: <span class="hljs-built_in">std_logic</span>; <span class="hljs-comment">-- 实例化的时候有一个输出管脚没有用到，但我不太会设置这个空管脚，就直接写了一个没有用到的信号</span><br><br><span class="hljs-keyword">begin</span><br><br>    <span class="hljs-comment">-- 以下都是f74161的实例化，需要设置port map，里面signal的顺序就是上面声明时port的顺序</span><br>counter0 : f74161 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(CLR, LOAD, D(<span class="hljs-number">3</span>), D(<span class="hljs-number">2</span>), D(<span class="hljs-number">1</span>), E, D(<span class="hljs-number">0</span>), E, CPuPC, rco_wire(<span class="hljs-number">0</span>), Q(<span class="hljs-number">3</span>), Q(<span class="hljs-number">2</span>), Q(<span class="hljs-number">1</span>), Q(<span class="hljs-number">0</span>));<br>counter1 : f74161 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(CLR, LOAD, D(<span class="hljs-number">7</span>), D(<span class="hljs-number">6</span>), D(<span class="hljs-number">5</span>), rco_wire(<span class="hljs-number">0</span>), D(<span class="hljs-number">4</span>), rco_wire(<span class="hljs-number">0</span>), CPuPC, rco_wire(<span class="hljs-number">1</span>), Q(<span class="hljs-number">7</span>), Q(<span class="hljs-number">6</span>), Q(<span class="hljs-number">5</span>), Q(<span class="hljs-number">4</span>));<br>counter2 : f74161 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(CLR, LOAD, D(<span class="hljs-number">11</span>), D(<span class="hljs-number">10</span>), D(<span class="hljs-number">9</span>), rco_wire(<span class="hljs-number">1</span>), D(<span class="hljs-number">8</span>), rco_wire(<span class="hljs-number">1</span>), CPuPC, rco_wire(<span class="hljs-number">2</span>), Q(<span class="hljs-number">11</span>), Q(<span class="hljs-number">10</span>), Q(<span class="hljs-number">9</span>), Q(<span class="hljs-number">8</span>));<br>counter3 : f74161 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(CLR, LOAD, D(<span class="hljs-number">15</span>), D(<span class="hljs-number">14</span>), D(<span class="hljs-number">13</span>), rco_wire(<span class="hljs-number">2</span>), D(<span class="hljs-number">12</span>), rco_wire(<span class="hljs-number">2</span>), CPuPC, useless, Q(<span class="hljs-number">15</span>), Q(<span class="hljs-number">14</span>), Q(<span class="hljs-number">13</span>), Q(<span class="hljs-number">12</span>));<br><br><br><span class="hljs-keyword">end</span> rtl;<br><br></code></pre></td></tr></table></figure><hr /><ul><li><a href="https://www.nandland.com/vhdl/tutorials/index.html" title="Nandland VHDL tutorial">参考</a></li></ul><hr /><h2 id="附件">附件</h2><p>计算机组成课程设计实验</p><h3 id="实验一">实验一</h3><p><a href="/files/HW/Computer%20Organization%20experiment/exp1/exp1.zip" title="exp1.zip contains the vhd codes and some .bdf files">click to download exp1</a></p><h3 id="实验二">实验二</h3><p><a href="/files/HW/Computer%20Organization%20experiment/exp2/exp2.zip" title="exp2.zip contains the vhd codes and some .bdf files">click to download exp2</a></p><h3 id="实验三">实验三</h3><p><a href="/files/HW/Computer%20Organization%20experiment/exp3/exp03.zip" title="exp3.zip contains the vhd codes and some .bdf files">click to download exp3</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming language </category>
          
          <category> Computer Organization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> VHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression and Maximum Entropy Model</title>
      <link href="/2021/02/15/Logistic-regression/"/>
      <url>/2021/02/15/Logistic-regression/</url>
      
        <content type="html"><![CDATA[<h1 id="logistic-regression">Logistic Regression</h1><p>简介：一种简单的统计分类方法，因为使用了Logistic函数得名。称作回归(Regression)的原因是，这个模型实质是在做函数的拟合问题。</p><h2 id="logistic-function">Logistic Function</h2><p><span class="math display">\[f(x)=\frac{1}{1+e^{-x}}\]</span></p><p>介于<span class="math inline">\(0\)</span> ~ <span class="math inline">\(1\)</span>之间</p><h2 id="二分类的logistic模型">二分类的Logistic模型</h2><p><span class="math display">\[P(Y=1|x)=\frac{exp(w\cdot x+b)}{1+exp(w\cdot x+b)}\]</span> <span class="math display">\[P(Y=0|x)=\frac{1}{1+exp(w\cdot x+b)}\]</span> <span class="math inline">\(w，x \in \mathbf{R}^n\)</span> , <span class="math inline">\(b \in \mathbf{R}\)</span></p><p>将 <span class="math inline">\(b\)</span> 并入到 <span class="math inline">\(w\)</span> 中，扩充 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(x\)</span> ，从而得到更简洁的表达 <span class="math display">\[P(Y=1|x)=\frac{exp(w\cdot x)}{1+exp(w\cdot x)}\]</span> <span class="math display">\[P(Y=0|x)=\frac{1}{1+exp(w\cdot x)}\]</span></p><h3 id="对模型的理解">对模型的理解</h3><h4 id="几率odd">几率(odd)</h4><p>记事件发生的概率为 <span class="math inline">\(p\)</span> ，那么事件发生的几率为 <span class="math inline">\(\frac{p}{1-p}\)</span></p><p>对数几率(log odd / logit 函数) <span class="math display">\[logit(p)=log\frac{p}{1-p}\]</span> 对于Logistic回归来说 <span class="math display">\[log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x\]</span> 可以看出，这是在用线性模型来拟合logit函数，故称为“回归模型”</p><h4 id="logistic函数">Logistic函数</h4><p>另一个角度看，Logistic函数将原本取值在实数集上的变量投影到了<span class="math inline">\((0,1)\)</span> ，也就是一个概率所属的范围。</p><h3 id="模型的求解">模型的求解</h3><p>极大似然估计，采用数值分析的方法(梯度下降法，拟牛顿法等)求解参数向量 <span class="math inline">\(w\)</span></p><h3 id="多分类的logistic回归模型">多分类的Logistic回归模型</h3><p><span class="math inline">\(Y\)</span> 的取值范围是{1, 2, 3, ... , K} <span class="math display">\[P(Y=k|x)=\frac{exp(w_k \cdot x)}{1+\sum_{k=1}^{K-1}exp(w_k\cdot x)},\quad k=1,2,\dots, K-1 \]</span> <span class="math display">\[P(Y=K|x)=\frac{1}{1+\sum_{k=1}^{K-1}exp(w_k\cdot x)}\]</span></p><h1 id="最大熵模型">最大熵模型</h1><p>简介：最大熵模型是根据最大熵原理得到的，简单说，在所有可能的概率模型中，熵最大的模型是最好的，因为它保留了最大的不确定性，所有不确定的部分都是接近"等可能的"，减小了对不确定因素的偏见。</p><h2 id="模型的定义">模型的定义</h2><p>利用最大熵原理，获得一个简单的分类模型。这里所求的模型是条件概率模型。根据给定的训练集，可以获得联合分布<span class="math inline">\(P(X,Y)\)</span>的经验分布，以及边缘分布<span class="math inline">\(P(X)\)</span>的经验分布，分别记为<span class="math inline">\(\tilde{P}(X,Y)\)</span> 和 <span class="math inline">\(\tilde{P}(X)\)</span> 。</p><h3 id="约束">约束</h3><p>约束就是分类问题中确定的条件，也就是输入与输出之间一些已知的事实。</p><p>约束用特征函数表示。 <span class="math display">\[f(x,y)=\left\{\begin{matrix}1 ,&amp; x和y满足某一事实\\ 0 ,&amp; 否则\end{matrix}\right.\]</span> 如果模型能够学习到数据中的信息，那么就可以<strong>假设</strong>特征函数关于经验分布和模型分布的期望是相等的。</p><p>关于经验分布的期望 <span class="math display">\[E_{\tilde{P}}(f)=\sum_{x,y}\tilde{P}(x,y)f(x,y)\]</span> 关于模型的条件分布的期望 <span class="math display">\[E_P(f)=\sum_{x,y}\tilde{P}(x)P(y|x)f(x,y)\]</span> 两者应当相等 ，即 <span class="math display">\[E_{\tilde{P}}(f)=E_P(f)\]</span></p><p>另外，特征函数也可不只一个。</p><h3 id="熵">熵</h3><p>条件熵 <span class="math display">\[H(P)=-\sum_{x,y}\tilde{P}(x)P(y\,|\,x)\,logP(y\,|\,x)\]</span></p><h3 id="模型学习">模型学习</h3><p>约束最优化问题 <span class="math display">\[\max_{P}\quad H(P)=-\sum_{x,y}\tilde{P}(x)P(y\,|\,x)\,logP(y\,|\,x)\]</span></p><p><span class="math display">\[s.t.\quad E_{\tilde{P}}(f_i)=E_P(f_i),\ i=1,2,...,n\]</span></p><p><span class="math display">\[\sum_yP(y\,|\,x)=1\]</span></p><p>根据拉格朗日乘子法， <span class="math display">\[L(P,w)=-H(P)+w_0\left ( 1-\sum_yP(y\,|\,x)\right)+\sum_{i=1}^{n}w_i(E_{\tilde{P}}(f_i)-E_P(f_i))\]</span> 问题转化为 <span class="math display">\[\min_{P}\max_{w}L(P,w)\]</span> 对偶问题 <span class="math display">\[\max_{w}\min_{P}L(P,w)\]</span> 因为<span class="math inline">\(L(P,w)\)</span> 是 P 的凸函数，故原始问题和对偶问题是等价的。(但其实两者等价的条件我还没学。。。我不懂，我不会)</p><p>通过对偶问题里面的极小化，可以获得一个含参的分布 <span class="math display">\[P_w(y\,|\,x)=\frac{1}{Z_w(x)}exp\left ( \sum_{i=1}^{n}w_if_i(x,y) \right )\]</span></p><p><span class="math display">\[Z_w(x)=\sum_yexp\left ( \sum_{i=1}^{n}w_if_i(x,y) \right )\]</span></p><p>其中<span class="math inline">\(Z_w(x)\)</span> 是正规化因子，<span class="math inline">\(w_i\)</span>是参数、权值。</p><p>下面在进一步去求外面的极大化就可以把参数求出来。</p><p>PS：最后一步的极大化其实等价于直接利用得到的含参的分布去做极大似然估计。</p><h3 id="模型求解">模型求解</h3><ul><li>有一个改进的迭代尺度法，计算每次参数 <span class="math inline">\(w\)</span> 的增量 <span class="math inline">\(\delta\)</span> , 关注<span class="math inline">\(L(w+\delta)-L(w)\)</span> , 经过放缩确定下界， 为了得到更大的该变量。放缩是因为，原式太复杂。</li><li>拟牛顿法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸函数</title>
      <link href="/2021/01/27/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
      <url>/2021/01/27/%E5%87%B8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考书 Boyd <em>Convex Optimization</em></p><h2 id="基本的概念和性质">基本的概念和性质</h2><h3 id="什么是凸函数">什么是凸函数</h3><p><span class="math inline">\(f:\mathbf {R}^n \rightarrow \mathbf {R}, \quad \mathbf {dom} f\)</span> 是个凸集，<span class="math inline">\(0 \leq \theta \leq 1\)</span> <span class="math display">\[f(\theta x + (1-\theta)y)\leq \theta f(x) + (1-\theta)f(y)\]</span> 严格凸就是不会取到等号</p><p>凹函数就是凸函数加个负号</p><p>仿射函数是比较特殊的，它既是凸函数又是凹函数，反过来也成立。相当于凹函数和凸函数的一个共有的临界的函数。</p><h4 id="扩展值延伸">扩展值延伸</h4><p>为了让凸函数在整个实数集上有定义，在定义域外令值为无穷，具体的为正无穷<span class="math inline">\(+\infty\)</span>(相反，若为凹函数，则定义为负无穷<span class="math inline">\(-\infty\)</span>) <span class="math display">\[\tilde{f}(x)=\left\{\begin{matrix}f(x) &amp;x\in\mathbf{dom}f\\ \infty &amp; x\notin \mathbf{dom}f\end{matrix}\right.\]</span></p><h3 id="判定条件">判定条件</h3><h4 id="一阶条件">一阶条件</h4><p>假设 <span class="math inline">\(f\)</span> 可微，对 <span class="math inline">\(\forall x,y \in \mathbf{dom}f\)</span> <span class="math display">\[f(y) \geqslant  f(x) + \bigtriangledown f(x)^T(y-x)\]</span> 联系了局部信息和全局信息</p><p>严格凸及凹的情况略</p><h4 id="二阶条件">二阶条件</h4><p>假设二阶可微，其Hessian矩阵是半正定的</p><p>未完待续。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Basic </category>
          
          <category> Optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
            <tag> Study </tag>
            
            <tag> convex function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT</title>
      <link href="/2020/12/02/FFT/"/>
      <url>/2020/12/02/FFT/</url>
      
        <content type="html"><![CDATA[<p>note : 本文仅简要地介绍FFT以及它的简单应用, 并不会过多的进行数学推导.</p><h2 id="background">Background</h2><p>首先我们回忆一下傅里叶级数.</p><h5 id="实数上的情形">实数上的情形</h5><p>对于一个函数<span class="math inline">\(f(x)\)</span>, 我们现在关注它在<span class="math inline">\([-\pi,\pi]\)</span> 这个区间上的表现.</p><p>它能够写成(在一定条件下) <span class="math display">\[f(x) = \frac{a_0}{2} + \sum_{k=1}^{\infty} a_kcos(kx)+b_ksin(kx)\]</span> 这里 <span class="math display">\[\begin{align*}a_k = \frac{1}{\pi}\int_{-\pi}^{\pi} f(x)cos(kx)dx \\\\b_k = \frac{1}{\pi}\int_{-\pi}^{\pi} f(x)sin(kx)dx\end{align*}\]</span> 虽然这里我们考虑的是在区间<span class="math inline">\([-\pi,\pi]\)</span> 上, 但现在 <span class="math inline">\(f\)</span> 现在在整个<span class="math inline">\(\textbf{R}\)</span> 具有了周期性, 周期是<span class="math inline">\(2\pi\)</span>.</p><p>另一方面, <span class="math inline">\(f(x)\)</span> 要满足"平方可积", 详细来说, 所有平方可积的函数构成一个线性空间. 更进一步的有关希尔伯特空间等泛函分析的内容.</p><p>那这个线性空间自然具有一个无限维的基. 在傅里叶级数中, 选择的基是 <span class="math display">\[\\{ 1, cos(x), sin(x), cos(2x), sin(2x), \dots \\}\]</span> 在确定内积 <span class="math display">\[\left \langle f,g\right \rangle = \int_{-\pi}^{\pi}f(x)\overline{g(x)}dx\]</span> 后,这组由 <span class="math inline">\(cos(kx),sin(kx)\dots\)</span> 构成的基成为了一组正交基. 当然你可以选择规范化, 去除以每个的范数.</p><h5 id="复数上的情形">复数上的情形</h5><p>把实数上的情形推广到复数上, 这里是说<span class="math inline">\(f(x)\)</span> 现在是复数函数, (x依然是实数).</p><p>我们有了更一般一点的傅里叶级数 <span class="math display">\[f(x) = \sum_{k=-\infty}^{+\infty} c_k e^{ikx}\]</span> 这里 <span class="math display">\[c_k = \frac{\left \langle f(x), e^{ikx} \right\rangle}{\left \|e^{ikx} \right \|^2} = \frac{1}{2\pi}\int_{-\pi}^{\pi} f(x)e^{-ikx}dx\]</span> (注: Euler公式 <span class="math inline">\(e^{ix}=cos(x) + i sin(x) ,\quad i=\sqrt{-1}\)</span>)</p><p>仍然是用许多的<span class="math inline">\(cos(kx), sin(kx)\)</span>去表达<span class="math inline">\(f(x)\)</span>, 只不过变成了复数.</p><p>前面一直讲的是<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([-\pi,\pi]\)</span>上的一些事情, 实际上这并不是唯一的.</p><p>现在换成区间<span class="math inline">\([-L,L]\)</span> 做个映射, <span class="math inline">\(x \to \pi x/L\)</span></p><p>记 <span class="math display">\[\psi_k(x)=e^{i\pi kx/L}\]</span></p><p>有 <span class="math display">\[c_k = \frac{\left \langle f(x), \psi_k(x) \right\rangle}{\left \|\psi_k(x) \right \|^2} = \frac{1}{2L}\int_{-L}^{L} f(x)\psi_k(x)dx\]</span></p><p>所以 <span class="math display">\[f(x) = \sum_{k=-\infty}^{\infty}c_k\psi_k(x)=\frac{1}{2L}\sum_{k=-\infty}^{\infty}\left \langle f(x), \psi_k(x) \right\rangle \psi_k(x)\]</span></p><p>这里观察这个级数, 它实际是在将<span class="math inline">\(f(x)\)</span> 分解成一系列<span class="math inline">\(\psi_k(x)\)</span> 的线性组合. 或者说一系列<span class="math inline">\(cos(2\pi kx/L), sin(2\pi kx/L)\)</span> 的结合. 这里面<span class="math inline">\(k\)</span> 蕴含着不同的正弦函数的频率.</p><p>记 <span class="math display">\[\omega_k = \pi k/L \\\\\Delta \omega = \pi/L\]</span> 那么 <span class="math display">\[\begin{align*}c_k = \frac{1}{2L} \int_{-L}^{L} f(x)&amp; e^{-ik{\Delta\omega}x}dx = \frac{1}{2L}\int_{-L}^{L} f(x)e^{-i\omega_kx}dx \\\\f(x)=&amp; \sum_{k=-\infty}^{+\infty}c_k e^{i\omega_k x}=\sum_{k=-\infty}^{+\infty}c_k e^{ik\Delta \omega x}\end{align*}\]</span></p><p>每个<span class="math inline">\(c_k\)</span>都对应着一个<span class="math inline">\(\omega_k\)</span>, 表示这个频率的函数所占的比重.</p><p>当<span class="math inline">\(L \to +\infty\)</span>, 也就是说<span class="math inline">\(f(x)\)</span> 在<span class="math inline">\(\textbf{R}\)</span> 上非周期. 我们就得到了傅里叶变换. <span class="math display">\[\begin{align*}\hat f(\omega) &amp; = \mathcal{F(f(x))}=\int_{-\infty}^{\infty} f(x)e^{-i\omega x}dx\\\\f(x) =&amp; \mathcal{F^{-1}(\hat f(\omega))} = \frac{1}{2\pi}\int_{-\infty}^{\infty} \hat f(\omega)e^{i\omega x}d\omega\end{align*}\]</span></p><p>有趣的性质:</p><p><span class="math display">\[\begin{align*}&amp; \mathcal{F(\frac{d}{dx}f(x)) = i\omega F(f(x))}\\\\\\\\&amp; \mathcal{F(g\times f) = F(g)F(f)}\end{align*}\]</span></p><h2 id="dft">DFT</h2><p>对于计算机, 我们既不能方便的处理无穷级数, 也不好处理积分. 连续的情况对计算机来说比较困难. 所以出现了离散的傅里叶变换. 他的大致含义还是一样的.</p><p>对一个<span class="math inline">\(f(x)\)</span>进行采样, 在0, 1, 2, ... , n - 1处的值, 分别为<span class="math inline">\([f_0, f_1,f_2,...,f_{n-1}]\)</span> , 这个向量代替了原来的函数</p><p>经过傅里叶变换后的函数变成了 <span class="math inline">\([\hat f_0, \hat f_1, \hat f_2...\hat f_{n-1}]\)</span></p><p>对于 <span class="math inline">\(\omega\)</span> 的选取也有原先连续的情况变成离散. 将 <span class="math inline">\(2\pi\)</span> 平均分成了 n 份. 每一份长度是 <span class="math inline">\(\frac{2\pi}{n}\)</span> 作为一个基本的单元.</p><p>之前的函数 <span class="math inline">\(\psi_k(x)\)</span> 成为了 <span class="math inline">\([(e^{2\pi ik/n})^j], j=0,1,2,...,n-1\)</span></p><p>简单来说, DFT的形式就是 <span class="math display">\[\begin{align*}\hat f_k=\sum_{j=0}^{n-1}f_j e^{-2\pi ijk/n}\\\\f_k = \frac{1}{n}\sum_{j=0}^{n-1}\hat f_k e^{2\pi ijk/n}\end{align*}\]</span></p><p>注意 <span class="math inline">\(e^{2\pi ik/n},\quad k=0,1,2...,n-1\)</span> 就是 <span class="math inline">\(x^{n}=1\)</span> 的解</p><p><span class="math inline">\(\psi_k = \left[  \begin{matrix}  1 \\\\  e^{2\pi ik/n} \\\\  (e^{2\pi ik/n})^2 \\\\  \vdots \\\\  (e^{2\pi ik/n})^{n-1}  \end{matrix}  \right]\)</span> 可以看作是不同频率的函数, 那么<span class="math inline">\(\hat f_k\)</span> 便可以看作是对应的<span class="math inline">\(\psi_k\)</span> 所占的大小.</p><p>首先举个简单的例子去直观的理解这个变换.</p><p>我们在函数<span class="math inline">\(f(x)=cos(2\pi \times 50 x)+cos(2\pi \times 75x)\)</span> 上进行采样, 同时我们加上一个随机的噪声,范围是<span class="math inline">\([-4,4]\)</span></p><div data-align="center"><img src="\upload_image\original.jpg" class="lazy" data-srcset="\upload_image\original.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="original" /></div><p>黑色的是原图像, 蓝色的部分是加入噪声后的图象. 当然这里的数据都是离散的, 只不过画图的时候被连在了一起.看上去像连续的.</p><p>现在我们得到了采样后的一个<span class="math inline">\(f(x)\)</span>的向量, <span class="math inline">\([f_0,f_1,f_2,...,f_{n-1}]\)</span></p><p>经过DFT后, 我们能得到一个<span class="math inline">\(\hat f\)</span> 向量, 由于是复数, 这里只展示向量中每个复数的模长的平方. 可以看作是一种能量.</p><div data-align="center"><img src="\upload_image\after_FFT.jpg" class="lazy" data-srcset="\upload_image\after_FFT.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="after FFT" /></div><p>下面的图是经过DFT后的样子, 明显可以看到, 里面有两个非常高的点. 对应着原始的没有加入噪声的<span class="math inline">\(cos(2\pi \times 50 x)\)</span> 和 <span class="math inline">\(cos(2\pi \times 75x)\)</span> , 如果我们设置一个阈值, 小于100的置位0, 这样就能去除噪声.</p><div data-align="center"><img src="\upload_image\after.jpg" class="lazy" data-srcset="\upload_image\after.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="filtered" /></div><p>中间的图就是对<span class="math inline">\(\hat f\)</span> 进行过滤之后再经过DFT的逆操作的得到的图象, 会发现它完全去除了噪声, 还原了最初的<span class="math inline">\(f(x)\)</span> .</p><h3 id="计算dft">计算DFT</h3><p>下面的问题是如何去计算DFT呢, <span class="math display">\[\begin{align*}\hat f_k=\sum_{j=0}^{n-1}f_j e^{-2\pi ijk/n}\\\\f_k = \frac{1}{n}\sum_{j=0}^{n-1}\hat f_k e^{2\pi ijk/n}\end{align*}\]</span> 容易看到这实质上是一个矩阵乘法.</p><p>记 <span class="math inline">\(\omega_n = e^{-2\pi i/n}\)</span> <span class="math display">\[\hat f=\left [ \begin{matrix} \hat f_0 \\\\ \hat f_1 \\\\ \hat f_2 \\\\ \vdots \\\\ \hat f_{n-1}\end{matrix} \right ]= \left [ \begin{matrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; \dots &amp; 1 \\\\1 &amp; \omega_n &amp; \omega_n^{2} &amp; \omega_n^{3} &amp; \dots &amp; \omega_n^{n-1}\\\\1 &amp; \omega_n^{2} &amp; \omega_n^{4} &amp; \omega_n^{6} &amp; \dots &amp; \omega_n^{2(n-1)} \\\\  &amp;   &amp; \vdots &amp;  &amp; \dots &amp;\vdots \\\\1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \omega_n^{3(n-1)} &amp; \dots &amp; \omega_n^{(n-1)(n-1)}\end{matrix}\right]\left[ \begin{matrix}f_0 \\\\  f_1 \\\\  f_2 \\\\ \vdots \\\\  f_{n-1}\end{matrix}\right]\]</span> 记这个矩阵为<span class="math inline">\(\mathcal{F_n}\)</span> , 或者称为DFT矩阵.</p><p>实质上<span class="math inline">\(\mathcal{F}\)</span> 乘上它的共轭转置 <span class="math inline">\(\mathcal{F^*}\)</span> 等于 <span class="math inline">\(nE_n\)</span>， 所以它的逆矩阵是很好求的，DFT的逆变换也很容易得出.</p><p>如果直接去求这个矩阵，复杂度是比较高的<span class="math inline">\(O(n^2)\)</span></p><p>但是如果考虑到 <span class="math inline">\(\omega_n\)</span> 的特殊的性质，便能得到非常高效的<span class="math inline">\(O(nlogn)\)</span> 的算法，也就是FFT</p><h3 id="fft">FFT</h3><p>FFT就是一种计算DFT的高效的算法，它最初是由高斯提出.</p><p>简单来说，我们想要快速的计算矩阵<span class="math inline">\(\mathcal{F_n}\)</span> ，通过将他分解为更小的子问题，转而去求解<span class="math inline">\(\mathcal{F_{\frac{n}{2}}}\)</span>. 这里我们现在只考虑 n 是2的幂的情况. 如果n不是2的幂的话， 我们可以简单的扩充成2的幂， 并不会影响算法的效率.</p><p>不同的矩阵<span class="math inline">\(\mathcal{F_n}\)</span> 内所使用的<span class="math inline">\(\omega_n\)</span> 是不同的， 但对于n 和 n/2 我们有 <span class="math inline">\(\omega_n^2=\omega_{n/2}\)</span> 可以轻松的进行转化。</p><p>核心的想法就是对<span class="math inline">\([f_0, f_1,...,f_{n-1}]\)</span> 进行重新排序， 按照下标的奇偶进行分组.</p><p>对于多项式 <span class="math display">\[\begin{align*}p(x) =&amp; a_0+a_1x+a_2x^2+\dots+a_{n-1}x^{n-1} \\\\     =&amp; (a_0 + a_2x^2 + a_4x^4 + \dots + a_{n-2}x^{n-2})\\\\      &amp;+ x(a_1 + a_3x^2+a_5x^4+\dots a_{n-1}x^{n-2})\\\\     =&amp; E(x) +xO(x)\end{align*}\]</span></p><p>同理，对于这里的DFT， 我们就会的到 <span class="math display">\[\begin{align*}\hat f_k =&amp; \sum_{j=0}^{n-1}f_j(\omega_n^k)^j\\\\         =&amp; \sum_{j=0}^{n/2-1}f_{2j}(\omega_n^k)^{2j} +\omega_n^k\sum_{j=0}^{n/2-1}f_{2j+1}(\omega_n^k)^{2j}\\\\         =&amp; \sum_{j=0}^{n/2-1}f_{2j}(\omega_{n/2}^k)^{j} +\omega_n^k\sum_{j=0}^{n/2-1}f_{2j+1}(\omega_{n/2}^k)^{j}\\\\         =&amp; E + \omega_n^k O\end{align*}\]</span></p><p><span class="math inline">\(E\)</span> 和 <span class="math inline">\(O\)</span> 便是我们的两个相同的子问题.</p><p>如果我们分别利用 <span class="math inline">\(f_{even}\)</span> 和 <span class="math inline">\(f_{odd}\)</span> 计算出了<span class="math inline">\(E\)</span> 和 <span class="math inline">\(O\)</span> 我们便能很快的根据上面的式子计算出所有的<span class="math inline">\(\hat f_k\)</span></p><p>不仅如此，我们可以利用 <span class="math display">\[\omega_n^{k+n/2} = -\omega_n^{k}\]</span> 进一步的简化. <span class="math display">\[\begin{align*}\hat f_k=E+\omega_n^kO\\\\\hat f_{k+n/2}=E-\omega_n^kO\end{align*}\]</span> 这样只需要一半的循环，就能计算出全部的<span class="math inline">\(\hat f_k\)</span> <span class="math display">\[\begin{align*}\hat f=\left [ \begin{matrix} \hat f_0 \\\\ \hat f_1 \\\\ \hat f_2 \\\\ \vdots \\\\ \hat f_{n-1}\end{matrix} \right ]=&amp;\mathcal{F_n}\left[ \begin{matrix}f_0 \\\\  f_1 \\\\  f_2 \\\\ \vdots \\\\  f_{n-1}\end{matrix}\right]\\\\=&amp;\left[ \begin{matrix}E_{n/2} &amp; D_{n/2} \\\\\\\\E_{n/2} &amp; -D_{n/2}\end{matrix}\right]\left[ \begin{matrix}\mathcal{F_{n/2}} &amp; O \\\\\\\\O &amp; \mathcal{F_{n/2}}\end{matrix}\right]\left[ \begin{matrix}f_{even}\\\\\\\\f_{odd}\end{matrix}\right]\end{align*}\]</span></p><p>如此算法的复杂度达到了<span class="math inline">\(O(nlogn)\)</span> ，如果利用并行计算，可以达到更快.</p><h3 id="fft的应用">FFT的应用</h3><ul><li>像前面做过的去除噪声便是一个很常见的应用</li><li>图象压缩</li><li>多项式乘法或者大整数乘法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word2Vec</title>
      <link href="/2020/11/11/Word2Vec/"/>
      <url>/2020/11/11/Word2Vec/</url>
      
        <content type="html"><![CDATA[<h3 id="beginning">beginning</h3><p>其实用向量来表示一个单词是很常见的, 毕竟方便一个算法或模型去表示一个单词. 但表示的方法很重要, 最完美的Embedding就是能够包含单词的语义, 相似语义的单词的表示越接近, 反之表示的向量差距越大. 下面一步步的去完成我们的目标.</p><h4 id="distance">distance</h4><p>怎么来叙述两个单词的embedding是相近的呢? 容易想到对于两个向量, 我们有一个适用于 <span class="math inline">\(n\)</span> 维空间上的一个夹角公式. for <span class="math inline">\(\vec{a}\)</span>, <span class="math inline">\(\vec{b}\)</span> as two embedding vectors of different words. the cosine similarity is <span class="math display">\[Cosine Similarity(\vec{a}, \vec{b}) = \frac{\vec{a} \cdot \vec{b}}{|\vec{a}|\cdot|\vec{b}|}\]</span></p><p>这个评判函数相对简单, 也非常有效. 对于不同的问题, 我们也可以选择不同的距离函数.</p><h4 id="modeling">modeling</h4><p>embedding都是为了更好的完成一个task, 那么下面先来看一个简单的任务, 在完成任务的同时, 来获得一个适合它的embedding.</p><h5 id="predicting-next-word">predicting next word</h5><p>根据语境预测下一个单词是什么. 这是一个在日常生活中非常常见的任务. 简单来做, 就是分为三步, - 输入一个单词, 先获得对应的embedding - 利用embedding去预测下一个单词的embedding - 根据embedding映射到对应的单词, 然后输出</p><ul><li>数据集从哪来呢<ul><li>一般是Wikipedia的文章等等</li><li>构造许多定长的input - output对, 做法是window sliding with a fixed length, <strong>前面的都是input, 最后一个单词是output</strong></li></ul></li></ul><h5 id="problem">problem</h5><p>这么做有两个问题.</p><ul><li><p>预测一个单词怎么能只看前几个单词呢</p></li><li><p>最后有个 <span class="math inline">\(n \times d\)</span> , (其中 <span class="math inline">\(n\)</span> 表示Vacab的大小, <span class="math inline">\(d\)</span> 表示embedding的大小) , 这算起来太费时了</p></li></ul><h5 id="problem-solving">problem solving</h5><ul><li><p>取样时不仅取前面的, 把后面的也取了. 这叫skip gram.</p><ul><li>这就成了Clozing了</li><li>换个方法, 把他改成预测谁是neighbor, 输出可能是neighbor的概率</li></ul></li><li><p>computational problem咋整. 再调整我们的任务</p><ul><li><p>我们改成更小规模的模型, 给他一个input, 和一堆output, 然后输出这些output分别是不是他的neighbor</p></li><li><p>那有可能我们训出了一个人工智障, 他告诉我们这些全都是neighbor, 我们好像也没法反驳.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># are they neighbors? </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">model</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>, output</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure></li><li><p>给他来个negative sample, 告诉model他们<strong>不是</strong>neighbor, 这样model就成了个logistics regression模型, 规模小了很多</p></li><li><p>但咱采样的时候怎么知道他们到底有没有可能是neighbor, 我们手上的数据集肯定是不完备的呀</p></li><li><p>随机设为negative......</p></li></ul></li></ul><p>问题基本解决了, 下面看具体流程</p><h5 id="word2vec">Word2Vec</h5><ul><li><p>我们训两个embeddings, 叫做Embedding和Context, 分别为input和一组outputs做project. 获得两组embedding: <span class="math inline">\(\vec{input}\)</span> 和 <span class="math inline">\(\vec{output}\)</span>. 这个outputs肯定就是一些真正的neighbor(通过skip gram window sliding选出来的)加上一些随机的negative sample.</p></li><li><p>input <span class="math inline">\(\to\)</span> Embedding <span class="math inline">\(\to\)</span> <span class="math inline">\(\vec{input}\)</span></p><p>outputs <span class="math inline">\(\to\)</span> Context <span class="math inline">\(\to\)</span> a set of <span class="math inline">\(\vec{output}\)</span>s</p></li><li><p>然后点乘, 来个softmax, 获得这么个概率, 根据误差不断训</p></li><li><p>最后, 训得差不多了, 扔掉context, 这个Embedding就是炼出来的丹</p></li></ul><h4 id="last">last</h4><ul><li>语义相近的那些单词, 被认为是所在的Context是相似的. 越相似的词点乘上Context, 得到的结果肯定都很接近正确结果.</li><li>这个window sliding 的length一般设成5, 越小的话得到的embedding划的越细, 就是说相近的embedding的单词所在的context几乎一样, 但要注意, 反义词很多时候也是这样, 把length设大点就能区分更多语境</li></ul><h3 id="end">End</h3><h5 id="reference">reference</h5><ul><li><a href="http://jalammar.github.io/illustrated-word2vec/">a blog</a></li><li>还没看过原paper和代码, 估计等以后了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Machine Learning </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多边形的扫描转换与区域填充算法</title>
      <link href="/2020/11/09/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
      <url>/2020/11/09/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="多边形的扫描转换与区域填充算法">多边形的扫描转换与区域填充算法</h1><p>为了完成这次算法作业, 需要C++ 图形编程. 我选择了OpenGL. 配置起来有点麻烦, 又遇到了一些Bug, 最后索性用了GL里面的一个库, glut.h 进行尝试.</p><h6 id="cheating-code"><a href="https://blog.csdn.net/qq_34075012/article/details/53283372">Cheating Code</a></h6><h3 id="glut的学习">GLUT的学习</h3><p>用的Clion, 配置了库, 但是可能有问题, 至少Glut是能正常使用的</p><p>随便找的一篇博客<a href="https://blog.csdn.net/OOFFrankDura/article/details/80205718">配置OpenGL</a></p><p>随便找到的一篇<a href="https://www.academia.edu/3186255/GLUT_Tutorial">GLUT Tutorial</a></p><p>捣腾半天发现其实我需要的功能并不是很复杂, 也没用到太多glut.h更深入的东西. 了解了glut基本的结构以后还是比较容易看懂整体的流程的.</p><ul><li>main()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">glutInit(&amp;argc, argv);<span class="hljs-comment">// 初始化 glut</span><br><br>glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); <span class="hljs-comment">// 设置模式, 我现在只会选择单缓存还是双缓存, 或者深度缓存等等以及颜色</span><br>glutInitWindowSize(winX, winY);<br>glutCreateWindow(<span class="hljs-string">&quot;test&quot;</span>);<br>myInit(); <span class="hljs-comment">//设置背景之类的</span><br><br>glutDisplayFunc(display); <span class="hljs-comment">//这个传入的display貌似也被当做各种窗口变动recall函数</span><br><br>glutMouseFunc(processMouse);<br>glutKeyboardFunc(processKeyboard);<br><br>glutMainLoop();<br></code></pre></td></tr></table></figure><ul><li>myInit()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">glClearColor(<span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>, <span class="hljs-number">0.0</span>);<br>glClear(GL_COLOR_BUFFER_BIT);<br>glColor3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br>glPointSize(<span class="hljs-number">2.0</span>);<br>glMatrixMode(GL_PROJECTION);<br>glLoadIdentity();<br>gluOrtho2D(<span class="hljs-number">0</span>, winX, <span class="hljs-number">0</span>, winY); <span class="hljs-comment">// 类似于一个映射或投影之类的, 把最边界的地方所在的坐标确定, left, right, bottom, top, 这里这样就会让他变成常规的坐标系(原点在左下)</span><br><br>glFlush();<br></code></pre></td></tr></table></figure><ul><li>recall</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawLine</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>    glVertex2i(x1, y1);<br>    glVertex2i(x2, y2);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">processKeyboard</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key, <span class="hljs-type">int</span> _x, <span class="hljs-type">int</span> _y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(key == <span class="hljs-number">27</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">3</span>) &#123;<br>            Filling f = Filling(n, x, y); <span class="hljs-comment">//这个就是本文所作的填充算法</span><br>            glBegin(GL_LINES);<br>            f.fill(drawLine);<br>            glEnd();<br>            glFlush();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">processMouse</span><span class="hljs-params">(<span class="hljs-type">int</span> button, <span class="hljs-type">int</span> state, <span class="hljs-type">int</span> _x, <span class="hljs-type">int</span> _y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(state == GLUT_DOWN) &#123;<br>        x[n] = _x; y[n++] = winY - _y;<br>        glBegin(GL_POINTS);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            glVertex2i(x[i], y[i]);<br>        &#125;<br>        glEnd();<br>        glFlush();<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>    glClear(GL_COLOR_BUFFER_BIT);<br>    glClearColor(<span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>, <span class="hljs-number">255.0</span>, <span class="hljs-number">0.0</span>);<br>    glColor3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><br>    glBegin(GL_POINTS);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        glVertex2i(x[i], y[i]);<br>    &#125;<br>    glEnd();<br>    glFlush();<br>&#125;<br></code></pre></td></tr></table></figure><p>to be continue...</p><p>算法代码之后再说....</p>]]></content>
      
      
      <categories>
          
          <category> Assign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer模型学习笔记</title>
      <link href="/2020/11/09/Transformer%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/11/09/Transformer%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="transformer-模型学习笔记">Transformer 模型学习笔记</h1><h6 id="论文地址attention-is-all-you-need">论文地址<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a></h6><h6 id="nice-blog-for-illustrating-transformer-model"><a href="http://jalammar.github.io/illustrated-transformer/">Nice Blog for illustrating Transformer Model</a></h6><h6 id="seq2seq-with-attention"><a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">seq2seq with attention</a></h6><h4 id="提出的特点">提出的特点</h4><ul><li>RNN无法并行地去处理一个序列, 因为每个hidden state <span class="math inline">\(h_i\)</span>都是依赖于上一个hidden state <span class="math inline">\(h_{i-1}\)</span>以及input. 所以就要一个step接一个step的去循环, 对于很长的序列训练起来就很耗时. Transformer 模型<strong>利用Attention机制</strong>去捕获全局的input与output之间的依赖性, 实质上就是将整条序列看作一个input向量, 也就<strong>避免</strong>了循环神经网络中的"<strong>循环</strong>". 实质上算是对RNN循环过程的一个展开吧.</li><li><strong>完全使用Attention机制</strong>, 没有使用序列对齐的循环(sequence-aligned recurrence)或者卷积层</li></ul><h4 id="背景知识">背景知识</h4><h5 id="self-attention的优势">Self attention的优势</h5><ul><li>Gated RNNs 虽然在结构上能够记录前 <span class="math inline">\(n - 1\)</span> 个token的信息, 但实际上, 随着序列变长, 最早的token信息会变得很少, 这就会失去他的准确性, 这在翻译任务中就显得非常要命, 例如, 在English-to-French的翻译里, output的第一个词大概率是依赖于input开始的部分, 这样很可能会得到很差的结果. 而transformer模型似乎是靠着更大的存储和算力来强行将前 <span class="math inline">\(n\)</span> 个token利用attention融合起来. 这样看来, 似乎是对症下药, 实验上也得到了很好的结果.</li><li>而具体的self attention会在模型架构中介绍</li></ul><h5 id="word-embedding">Word Embedding</h5><h6 id="blog-for-introducing-word2vec"><a href="https://medium.com/deeper-learning/glossary-of-deep-learning-word-embedding-f90c3cec34ca">Blog for introducing Word2Vec</a></h6><p>我自己的<a href="https://furyton.github.io/2020/11/11/Word2Vec/">对Word2Vec的学习笔记</a></p><h4 id="模型架构">模型架构</h4><p>其实Transformer模型的改进应该去对比seq2seq with attention模型</p><ul><li><p>首先在seq2seq模型里,用的是最初的encoder-decoder思想, 拿翻译任务来说, input就是一个句子, encoder需要一个单词一个单词(token)的去encode, 也就是扔进一个RNNs, 每次得到一个hidden state, 句子全输进去了, 最后得到的hidden state就可以作为整个句子的representation. 这个思想很简单, 给我的是不定长的, 那我就把他搞成一个固定长度的hidden state. 之后拿着这个representation当作decoder的input, 再一个单词一个单词的预测. 前后都是RNN.</p><p>乍一看貌似还是挺好的, 但问题是RNN的记忆机制和梯度问题解决的不是那么好, 句子长了前面的单词他就忘记了. 而且翻译这个任务也确实需要一种attention ,output的某一个部分会很大程度依赖于input中的一部分.</p></li><li><p>加了attention的seq2seq似乎就考虑到了这种依赖关系, attention机制也很好的做到了这一点. 至于整体做法, 上面不是说encoder内不断地生成hidden state吗, 那我们就把它们全都取出来作为decoder的input, 这样就不用太担心记忆的问题了, 毕竟你把它们都拿出来了. 然后每个output预测值会利用attention机制去给这些hidden state附上注意力的权重, 来更好地完成任务.</p></li><li><p>再到transformer. 这样纵向的来看, 似乎改进的地方确实如原论文所讲, 去掉了所有的循环连接. 完全用attention来解决. 这样做就需要在一些地方进行调整.</p></li></ul><h5 id="attention">Attention</h5><p>虽然字面上讲的attention, 似乎是个很熟悉的概念, 但实际在具体的实现上是另一种更加抽象的机制.</p><p>一般来讲,这个问题是想输入两种序列, <span class="math inline">\(S= \{S_1, S_2, S_3 \dots S_n \}\)</span> 以及 <span class="math inline">\(T =\{T_1, T_2, T_3 \dots T_m \}\)</span> 我想输出<span class="math inline">\(T\)</span> 对于<span class="math inline">\(S\)</span> 的attention, 具体的可以说就是一个function, <span class="math inline">\(Attention_{S_i}(T_j),\quad i= 1,2\dots n\)</span></p><p>,然后有 <span class="math display">\[\sum_{j} Attention_{S_i}(T_j)=1, \quad i = 1,2,\dots n\]</span> 就可以,值越大就越重要. 那么整个T对于 <span class="math inline">\(S_i\)</span> 的representation就是 <span class="math inline">\(T_{s_i} = \sum_{j} Attention_{S_i} (T_j)\times Value(T_j)\)</span> 这么一个加权平均</p><p>这里的元素就是一些embedding, 一些向量.</p><p>Attention的求法类似于一种查询. 每个 <span class="math inline">\(S_i\)</span> 都会对应一个query向量 <span class="math inline">\(\boldsymbol{q_i}\)</span> 每个 <span class="math inline">\(T_i\)</span> 又对应一个键值 <span class="math inline">\(\boldsymbol{k_i}\)</span> 以供"查询", 查到的结果就是两个向量的点积 <span class="math inline">\(a_{ij} = \boldsymbol{q_i} \cdot \boldsymbol{k_j}\)</span> , (假设这里的两个向量的维数都是 <span class="math inline">\(d_k\)</span> ).</p><p>最后的Attention就是再加上一个softmax <span class="math display">\[Attention_{S_i}(T_j)  = \frac{e^{\boldsymbol{q_i} \cdot \boldsymbol{k_j}^T}}{\sum_j e^{\boldsymbol{q_i} \cdot \boldsymbol{k_j}^T}}\]</span></p><p>每个 <span class="math inline">\(T_j\)</span> 又会对应一个Value向量 <span class="math inline">\(v_j\)</span> (维度可以和前面两个向量不同, 记为<span class="math inline">\(d_v\)</span>)用以获得representation. 最后得到的就是 <span class="math display">\[Representation_{for\ S_i} = softmax(\boldsymbol{q}_{1\times d_k}\cdot \boldsymbol K_{m \times d_k}^T) \boldsymbol V_{m\times d_k}\]</span> 进一步可以获得 <span class="math inline">\(T\)</span> 对 <span class="math inline">\(S\)</span> 的表示 <span class="math display">\[softmax(\boldsymbol{Q}_{n\times d_k}\cdot \boldsymbol K_{m \times d_k}^T) \boldsymbol V_{m\times d_v}\]</span> 为了"having more stable gradients" , 在<span class="math inline">\(\boldsymbol{Q}\cdot \boldsymbol K^T\)</span>这里还要除以一个因子, 默认是 <span class="math inline">\(\sqrt{d_k}\)</span> ,</p><p>然后又变成了 <span class="math display">\[softmax(\frac{\boldsymbol{Q}\cdot \boldsymbol K^T}{\sqrt{d_k}}) \boldsymbol V\]</span> 有人要问了, 你说的这些query,key和value向量都咋求呢.</p><ul><li>用三个线性映射(矩阵) <span class="math inline">\(W^Q,W^K,W^V\)</span></li></ul><p>线性映射哪来的呢</p><ul><li>学出来的</li></ul><h5 id="a-beast-with-multihead">a beast with multihead</h5><p>这样一组attention可能注意力太集中, 看不全, 那我们就让他有多个"头", 注意力分散点, 看得更全</p><p><a href="https://colab.research.google.com/github/tensorflow/tensor2tensor/blob/master/tensor2tensor/notebooks/hello_t2t.ipynb">tensor2tensor</a>上有个示例, 演示的就是attention</p><p>一个比较经典的例子 翻译句子 The animal didn't cross the street because it was too tired</p><p>这里的 it 应该代指 The animal, 但是对模型来说, 他也可能是说the street.</p><div data-align="center"><img src="\upload_image\attention_with_one_head.png" class="lazy" data-srcset="\upload_image\attention_with_one_head.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="attention with one head" style="zoom:50%;" /></div><p>这里可以看到, 模型确实被it的代指给弄晕了,但还好animal处的颜色比street的地方要深,说明他的权值要大</p><div data-align="center"><img src="\upload_image\attention_with_one_head_2.png" class="lazy" data-srcset="\upload_image\attention_with_one_head_2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="attention with one head(2)" style="zoom: 50%;" /></div><p>但并不是所有的attention都能学到对应的部分.</p><p>解决办法就是, 我们用多个attention去拼接成最终想要的representation. 具体的, 我们得到的value向量不是 <span class="math inline">\(d_v\)</span> 维的吗, 假设我们有 <span class="math inline">\(h\)</span> 个head, 那么就把向量分为<span class="math inline">\(h\)</span> 个维度为 <span class="math inline">\(d_v / h\)</span> 的向量, 每个用各自的线性映射得到 <span class="math inline">\(h\)</span> 组不同的 <span class="math inline">\(\boldsymbol{Q,\, K,\, V_{m \times (d_v/h)}}\)</span> 去求各自的value(attention结构图片来自<a href="http://jalammar.github.io/illustrated-transformer/">这个blog</a>)</p><div data-align="center"><img src="\upload_image\multihead.png" class="lazy" data-srcset="\upload_image\multihead.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="multihead attention" style="zoom:50%;" /></div><p>最后一般还会再乘上一个矩阵 <span class="math inline">\(W^O\)</span>,来得到最后的输出</p><div data-align="center"><img src="\upload_image\attention_with_multihead.png" class="lazy" data-srcset="\upload_image\attention_with_multihead.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="attention with multihead" style="zoom:50%;" /></div><p>用上了多个head, 我们就能同时去关注不同的区域, 获得更准确的表述</p><div data-align="center"><img src="\upload_image\attention_with_3heads.png" class="lazy" data-srcset="\upload_image\attention_with_3heads.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="attention with 3 heads" style="zoom:50%;" /></div><h4 id="整体架构">整体架构</h4><p>前面花了较长篇幅讲了Attention机制, 这里再看下它是如何被用在Transformer中的</p><div data-align="center"><img src="\upload_image\transformer_model_arch.png" class="lazy" data-srcset="\upload_image\transformer_model_arch.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="transformer_model architecture" style="zoom:50%;"/></div><p>在上面的架构图中包含encoder以及decoder的结构(结构图来自原论文)</p><p>左边是encoder, 他的特点就是直接将整条序列直接放进网络层中.</p><p>工作流程就是, 首先把要处理的序列input输入, 再获得它的embeddings. 然后依次进入每个encoder层,</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> Machine Learning </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2020/11/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2020/11/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="this-is-my-first-blog-here">this is my first blog here</h1>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
